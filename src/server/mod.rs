//! TURN server implementation.

mod config;
mod request;

use std::{collections::HashMap, fmt, sync::Arc};

use tokio::{
    sync::{
        broadcast::{
            error::RecvError,
            {self},
        },
        mpsc, oneshot, Mutex,
    },
    time::{Duration, Instant},
};

use crate::{
    allocation::{AllocInfo, FiveTuple, Manager, ManagerConfig},
    con::Conn,
    AuthHandler, Error,
};

pub use self::config::{Config, ConnConfig};

/// `DEFAULT_LIFETIME` in RFC 5766 is 10 minutes.
///
/// [RFC 5766 Section 2.2](https://www.rfc-editor.org/rfc/rfc5766#section-2.2)
pub(crate) const DEFAULT_LIFETIME: Duration = Duration::from_secs(10 * 60);

/// MTU used for UDP connections.
pub(crate) const INBOUND_MTU: usize = 1500;

/// Server is an instance of the TURN Server
pub struct Server {
    /// [`AuthHandler`] used to authenticate certain types of requests.
    auth_handler: Arc<dyn AuthHandler + Send + Sync>,

    /// A string used to describe the server or a context within the server.
    realm: String,

    /// [Channel binding][1] lifetime.
    ///
    /// [1]: https://datatracker.ietf.org/doc/html/rfc5766#section-11
    channel_bind_lifetime: Duration,

    /// Nonces generated by server.
    pub(crate) nonces: Arc<Mutex<HashMap<String, Instant>>>,

    /// Channel to [`Server`]'s internal loop.
    command_tx: Mutex<Option<broadcast::Sender<Command>>>,
}

impl Server {
    /// creates a new TURN server
    #[must_use]
    pub fn new(config: Config) -> Self {
        let (command_tx, _) = broadcast::channel(16);
        let mut this = Self {
            auth_handler: config.auth_handler,
            realm: config.realm,
            channel_bind_lifetime: config.channel_bind_lifetime,
            nonces: Arc::new(Mutex::new(HashMap::new())),
            command_tx: Mutex::new(Some(command_tx.clone())),
        };
        if this.channel_bind_lifetime == Duration::from_secs(0) {
            this.channel_bind_lifetime = DEFAULT_LIFETIME;
        }
        for p in config.conn_configs {
            let nonces = Arc::clone(&this.nonces);
            let auth_handler = Arc::clone(&this.auth_handler);
            let realm = this.realm.clone();
            let channel_bind_lifetime = this.channel_bind_lifetime;
            let handle_rx = command_tx.subscribe();
            let conn = p.conn;
            let allocation_manager = Arc::new(Manager::new(ManagerConfig {
                relay_addr_generator: p.relay_addr_generator,
                alloc_close_notify: config.alloc_close_notify.clone(),
            }));

            Self::spawn_read_loop(
                conn,
                allocation_manager,
                nonces,
                auth_handler,
                realm,
                channel_bind_lifetime,
                handle_rx,
            );
        }

        this
    }

    /// Deletes all existing allocations by the provided `username`.
    ///
    /// # Errors
    ///
    /// With [`Error::Closed`] if the [`Server`] was closed already.
    pub async fn delete_allocations_by_username(
        &self,
        username: String,
    ) -> Result<(), Error> {
        let tx = self.command_tx.lock().await.clone();

        #[allow(clippy::map_err_ignore)]
        if let Some(tx) = tx {
            let (closed_tx, closed_rx) = mpsc::channel(1);
            _ = tx
                .send(Command::DeleteAllocations(username, Arc::new(closed_rx)))
                .map_err(|_| Error::Closed)?;

            closed_tx.closed().await;

            Ok(())
        } else {
            Err(Error::Closed)
        }
    }

    /// Returns [`AllocInfo`]s by specified [`FiveTuple`]s.
    ///
    /// If `five_tuples` is:
    /// - [`None`]:               It returns information about the all
    ///   allocations.
    /// - [`Some`] and not empty: It returns information about the allocations
    ///   associated with the specified [`FiveTuple`]s.
    /// - [`Some`], but empty:    It returns an empty [`HashMap`].
    ///
    /// # Errors
    ///
    /// With [`Error::Closed`] if the [`Server`] was closed already.
    pub async fn get_allocations_info(
        &self,
        five_tuples: Option<Vec<FiveTuple>>,
    ) -> Result<HashMap<FiveTuple, AllocInfo>, Error> {
        if let Some(five_tuples) = &five_tuples {
            if five_tuples.is_empty() {
                return Ok(HashMap::new());
            }
        }

        let tx = self.command_tx.lock().await.clone();
        #[allow(clippy::map_err_ignore)]
        if let Some(tx) = tx {
            let (infos_tx, mut infos_rx) = mpsc::channel(1);

            _ = tx
                .send(Command::GetAllocationsInfo(five_tuples, infos_tx))
                .map_err(|_| Error::Closed)?;

            let mut info: HashMap<FiveTuple, AllocInfo> = HashMap::new();

            for _ in 0..tx.receiver_count() {
                info.extend(infos_rx.recv().await.ok_or(Error::Closed)?);
            }

            Ok(info)
        } else {
            Err(Error::Closed)
        }
    }

    /// Spawns a message handler task for the given [`Conn`].
    fn spawn_read_loop(
        conn: Arc<dyn Conn + Send + Sync>,
        allocation_manager: Arc<Manager>,
        nonces: Arc<Mutex<HashMap<String, Instant>>>,
        auth_handler: Arc<dyn AuthHandler + Send + Sync>,
        realm: String,
        channel_bind_lifetime: Duration,
        mut handle_rx: broadcast::Receiver<Command>,
    ) {
        let (mut close_tx, mut close_rx) = oneshot::channel::<()>();

        drop(tokio::spawn({
            let allocation_manager = Arc::clone(&allocation_manager);

            async move {
                loop {
                    match handle_rx.recv().await {
                        Ok(Command::DeleteAllocations(name, completion)) => {
                            allocation_manager
                                .delete_allocations_by_username(name.as_str())
                                .await;
                            drop(completion);
                            continue;
                        }
                        Ok(Command::GetAllocationsInfo(five_tuples, tx)) => {
                            let infos = allocation_manager
                                .get_allocations_info(&five_tuples);
                            drop(tx.send(infos).await);

                            continue;
                        }
                        Err(RecvError::Closed) => {
                            close_rx.close();
                            break;
                        }
                        Ok(Command::Close(completion)) => {
                            close_rx.close();
                            drop(completion);
                            break;
                        }
                        Err(RecvError::Lagged(n)) => {
                            log::warn!(
                                "Turn server has lagged by {} messages",
                                n
                            );
                            continue;
                        }
                    }
                }
            }
        }));

        drop(tokio::spawn(async move {
            let local_con_addr = conn.local_addr();
            let protocol = conn.proto();

            loop {
                let (msg, src_addr) = tokio::select! {
                    v = conn.recv_from() => {
                        match v {
                            Ok(v) => v,
                            Err(err) => {
                                log::debug!("exit read loop on error: {}", err);
                                break;
                            }
                        }
                    },
                    () = close_tx.closed() => break
                };

                let handle = request::handle_message(
                    msg,
                    &conn,
                    FiveTuple { src_addr, dst_addr: local_con_addr, protocol },
                    realm.as_str(),
                    channel_bind_lifetime,
                    &allocation_manager,
                    &nonces,
                    &auth_handler,
                );

                if let Err(err) = handle.await {
                    log::error!("error when handling datagram: {}", err);
                }
            }

            drop(allocation_manager.close().await);
            drop(conn.close().await);
        }));
    }

    /// Close stops the TURN Server. It cleans up any associated state and
    /// closes all connections it is managing.
    pub async fn close(&self) {
        let tx = self.command_tx.lock().await.take();

        if let Some(tx) = tx {
            if tx.receiver_count() == 0 {
                return;
            }

            let (closed_tx, closed_rx) = mpsc::channel(1);
            drop(tx.send(Command::Close(Arc::new(closed_rx))));
            closed_tx.closed().await;
        }
    }
}

impl fmt::Debug for Server {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Server")
            .field("realm", &self.realm)
            .field("channel_bind_lifetime", &self.channel_bind_lifetime)
            .field("nonces", &self.nonces)
            .field("command_tx", &self.command_tx)
            .field("auth_handler", &"dyn AuthHandler")
            .finish()
    }
}

/// The protocol to communicate between the [`Server`]'s public methods
/// and the tasks spawned in the [`Server::spawn_read_loop`] method.
#[derive(Clone)]
enum Command {
    /// Command to delete [`Allocation`][`Allocation`] by provided `username`.
    ///
    /// [`Allocation`]: `crate::allocation::Allocation`
    DeleteAllocations(String, Arc<mpsc::Receiver<()>>),

    /// Command to get information of [`Allocation`][`Allocation`]s by provided
    /// [`FiveTuple`]s.
    ///
    /// [`Allocation`]: `crate::allocation::Allocation`
    GetAllocationsInfo(
        Option<Vec<FiveTuple>>,
        mpsc::Sender<HashMap<FiveTuple, AllocInfo>>,
    ),

    /// Command to close the [`Server`].
    Close(Arc<mpsc::Receiver<()>>),
}
